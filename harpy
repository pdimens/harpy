#!/usr/bin/env python3

import subprocess
import os
from os.path import exists
import sys

try:
    harpypath = '{CONDA_PREFIX}'.format(**os.environ) + "/bin"
except:
    import textwrap
    termwidth = os.get_terminal_size()[0]
    enverror = "\033[1;33mERROR:\033[00m Harpy expects to run from within an active conda environment, but one was not detected."
    print(textwrap.fill(enverror, width = termwidth))
    fix = "\033[1;34mSOLUTION:\033[00m Activate the conda environment Harpy was installed into and run Harpy again."
    print()
    print(textwrap.fill(fix, width = termwidth))
    print(f"\n\033[1mDetails:\033[00m")
    details = "In order to work correctly, Harpy expects several software packages to be available in the PATH, which are provided automatically with Harpy's conda-based installation. It also expects snakefiles, scripts, utilities, etc. to be in the /bin/ folder within that conda environment. If you're seeing this message, no active conda environment was detected upon execution, and Harpy exited as an early failsafe against unexpected runtime errors associated with \"missing\" files and packages."
    print(textwrap.fill(details, width = termwidth))
    exit(1)

import rich_click as click

click.rich_click.USE_MARKDOWN = True
click.rich_click.SHOW_ARGUMENTS = False
click.rich_click.SHOW_METAVARS_COLUMN = False
click.rich_click.APPEND_METAVARS_HELP = False
click.rich_click.REQUIRED_SHORT_STRING = ""
click.rich_click.ERRORS_SUGGESTION = "Try the '--help' flag for more information."
click.rich_click.ERRORS_EPILOGUE = "See the documentation: [link=https://pdimens.github.io/harpy/]https://pdimens.github.io/harpy/[/link]"


## recurring checks and such ##
def vcfcheck(vcf):
    vfile = vcf.lower()
    if vfile.endswith(".vcf") or vfile.endswith(".bcf") or vfile.endswith(".vcf.gz"):
        pass
    else:
        print(f"\033[1;33mERROR:\033[00m Supplied variant call file ({vcf}) must end in one of [.vcf | .vcf.gz | .bcf]")
        exit(1)

def getnames(directory, ext):
    samplenames = set([i.split(ext)[0] for i in os.listdir(directory) if i.endswith(ext)])
    if len(samplenames) < 1:
        print(f"\033[1;33mERROR:\033[00m No sample files ending with {ext} found in {directory}.")
        sys.exit(1)
    return samplenames

# Nicer version for init
def getnames_err(directory, ext):
    samplenames = set([i.split(ext)[0] for i in os.listdir(directory) if i.endswith(ext)])
    if len(samplenames) < 1:
        raise Exception("\033[1;33mERROR:\033[00m No sample files ending with {ext} found in {directory}.")
    return samplenames

# find fastq extension types
def fq_extension(directory):
    ext = set()
    rsep = set()
    err = ""
    for i in os.listdir(directory):
        if i.endswith(".fastq.gz") | i.endswith(".fq.gz"):
            sep = i.split(".")
            fq = ".".join(sep[-2:])          
            ext.add(fq)
            base = i.split(f".{fq}")[0]
            rsp = "".join(base[-2:]).lstrip('^_.-')
            rsep.add(rsp)
    if len(ext) < 1:
        print(f"\033[1;33mERROR:\033[00m No fastq.gz or fq.gz files identified in {directory}")
        sys.exit(1)
    if len(ext) > 1:
        err += f"- multiple file extensions detected: {ext}.\n  - format your files so there's only one style of .fq.gz | .fastq.gz\n"
    if len(rsep) > 2:
        err += f"- multiple read forward/reverse styles detected: {rsep}\n  - format your files so there's only one style of .1. | .F. | .R1.\n"
    if err != "":
        print("\033[1;33mERROR:\033[00m\n" + err)
        sys.exit(1)
    return (f"{list(ext)[0]}", sorted(rsep))


## the modules ##
click.rich_click.OPTION_GROUPS = {
    "harpy trim": [
        {
            "name": "Configuration",
            "options": ["--directory", "--max-length", "--extra-params"],
        },
        {
            "name": "Other Options",
            "options": ["--threads", "--snakemake", "--help"],
        },
    ],
    "harpy align": [
        {
            "name": "Configuration",
            "options": ["--genome", "--directory", "--quality-filter", "--method", "--ema-bins", "--extra-params"],
        },
        {
            "name": "Other Options",
            "options": ["--threads", "--snakemake", "--help"],
        },
    ],
    "harpy variants": [
        {
            "name": "Configuration",
            "options": ["--genome", "--directory", "--populations", "--ploidy", "--method", "--extra-params"],
        },
        {
            "name": "Other Options",
            "options": ["--threads", "--snakemake", "--help"],
        },
    ],
    "harpy impute": [
        {
            "name": "Configuration",
            "options": ["--vcf", "--directory", "--parameters"],
        },
        {
            "name": "Other Options",
            "options": ["--threads", "--snakemake", "--help"],
        },
    ],
    "harpy phase": [
        {
            "name": "Configuration",
            "options": ["--vcf", "--directory", "--molecule-distance", "--prune-threshold", "--extra-params"],
        },
        {
            "name": "Other Options",
            "options": ["--threads", "--snakemake", "--help"],
        },
    ]
}

@click.group(options_metavar='', context_settings=dict(help_option_names=["-h", "--help"]))
@click.version_option("0.1", prog_name="Harpy")
def cli():
    """
    ## Harpy haplotagging pipeline
    
    An automated workflow to trim reads, map sequences, call variants, impute genotypes,
    and phase haplotypes of Haplotagging data. Batteries included.
    
    **trim >> align >> variants >> impute >> phase**
    
    **Documentation**: [https://pdimens.github.io/harpy/](https://pdimens.github.io/harpy/)
    """
    pass

@click.command(no_args_is_help = True)
@click.option('-p', '--popgroup', required = False, type=click.Path(exists=True), metavar = "Input folder Path", help = 'Create generic sample-group file using existing sample file names (fq.gz or bam)')
@click.option('-s', '--stitch-params', type=str, metavar = "Output file name", help = 'Create template STITCH parameter file')
@click.option('-h', '--hpc', type = click.Choice(["slurm", "sge"], case_sensitive = False), help = 'Create HPC scheduling profile')
def extra(popgroup, stitch_params, hpc):
    """
    Create various optional/necessary input files

    With this command you can generate a sample grouping file (for variant calling),
    a templace STITCH parameter file (for imputation), and a HPC profile for running
    Harpy on a cluster. You can use any combination of options at a time. 
    """
    if popgroup is not None:
        print('\033[1m' + "<><> Sampling Grouping File <><>" + '\033[0m')
        try:
            samplenames = getnames_err(popgroup, '.bam')
        except:
            try:
                samplenames = set([i[:-2].rstrip('_.^') for i in getnames_err(popgroup, '.fastq.gz')])
            except:
                try:
                    samplenames = set([i[:-2].rstrip('_.^') for i in getnames_err(popgroup, '.fq.gz')])
                except:
                    print(f"\033[1;33mERROR:\033[00m No files ending in fq.gz, fastq.gz, or .bam found in {popgroup}")
                    sys.exit(1)

        print(f"Samples detected in {popgroup}: " + str(len(samplenames)))
        fout = "samples.groups"
        if exists("samples.groups"):
            overwrite = input("File \'samples.groups\' already exists, overwrite (no|yes)?  ").lower()
            if (overwrite == "no") or (overwrite == "n"):
                fout = input("Please suggest a different name for the output file: ")
            elif (overwrite == "yes") or (overwrite == "y"):
                fout = "samples.groups"
        with open(fout, "w") as file:
            for i in samplenames:
                file.write(i + '\t1\n') 
        print('Created sample population grouping file: ' + fout + '\nPlease review it, as all samples have been grouped into a single population\n')

    if stitch_params is not None:
        print('\033[1m' + "<><> STITCH Parameter File <><>" + '\033[0m')
        with open(stitch_params, "w") as file:
            file.write('model\tuseBX\tk\ts\tnGen\npseudoHaploid\tTRUE\t10\t5\t50\npseudoHaploid\tTRUE\t10\t1\t50\npseudoHaploid\tTRUE\t15\t10\t100')
        print(f"Created example parameter file: {stitch_params}")
        print("Modify the model parameters as needed, but " + '\033[1m' + "DO NOT" + '\033[0m' + " add/remove columns")

    if hpc is not None:
        print('\033[1m' + "<><> HPC Profile <><>" + '\033[0m')
        subprocess.run(["hpc_profile.py", hpc])


@click.command(no_args_is_help = True)
@click.option('-d', '--directory', required = True, type=click.Path(exists=True), metavar = "Folder Path", help = 'Directory with raw sample sequences')
@click.option('-l', '--max-length', default = 150, show_default = True, type=int, metavar = "Integer", help = 'Maximum length to trim sequences down to')
@click.option('-x', '--extra-params', type = str, metavar = "String", help = 'Additional Fastp parameters, in quotes')
@click.option('-t', '--threads', default = 4, show_default = True, type = click.IntRange(min = 4, max_open = True), metavar = "Integer", help = 'Number of threads to use')
@click.option('-s', '--snakemake', type = str, metavar = "String", help = 'Additional Snakemake parameters, in quotes')
def trim(directory, max_length, extra_params, threads, snakemake):
    """
    Remove adapters and quality trim sequences
    """
    # extension guessing
    fqext, Rsep = fq_extension(directory)
    try:
        fullext = [f".{Rsep[0]}.{fqext}", f".{Rsep[1]}.{fqext}"]
        samplenames = getnames_err(directory, fullext[0])
    except:
        try:
            fullext = [f"_{fqext[1][0]}.{fqext[0]}", f"_{fqext[1][1]}.{fqext[0]}"]
            samplenames = getnames_err(directory, fullext[0])
        except:
            print(f"\033[1;33mERROR:\033[00m No fastq files with acceptable names found in {directory}")
            print("Check that the files conform to [.1. | .F.][.fastq | .fq].gz")
            print("Read the documentation for details: https://pdimens.github.io/harpy/modules/qualitytrimming/")
    command = f'snakemake --cores {threads} --directory . --snakefile {harpypath}/trim.smk'.split()
    if snakemake is not None:
        [command.append(i) for i in snakemake.split()]
    command.append('--config')
    directory = directory.rstrip("/^")
    command.append(f"seq_directory={directory}")
    command.append(f"fqext={fullext}")
    command.append(f"samplenames={samplenames}")
    command.append(f"maxlen={max_length}")
    if extra_params is not None:
        command.append(f"extra={extra_params}")
    subprocess.run(command)

@click.command(no_args_is_help = True)
@click.option('-g', '--genome', type=click.Path(exists=True), required = True, metavar = "File Path", help = 'Genome assembly for read mapping')
@click.option('-d', '--directory', required = True, type=click.Path(exists=True), metavar = "Folder Path", help = 'Directory with sample sequences')
@click.option('-e', '--ema-bins', default = 500, show_default = True, type = click.IntRange(1,1000), metavar = "Integer", help="Number of barcode bins if using EMA")
@click.option('-m', '--method', default = "bwa", show_default = True, type = click.Choice(["bwa", "ema"], case_sensitive = False), metavar = "String", help = "Method for aligning reads")
#@click.option('--ema', is_flag=True, metavar = "Toggle", help="Use EMA instead of BWA MEM")
@click.option('-q', '--quality-filter', default = 30, show_default = True, type = click.IntRange(min = 0, max = 40), metavar = "Integer", help = 'Minimum mapping quality to pass filtering')
@click.option('-x', '--extra-params', type = str, metavar = "String", help = 'Additional EMA-align/BWA parameters, in quotes')
@click.option('-t', '--threads', default = 4, show_default = True, type = click.IntRange(min = 4, max_open = True), metavar = "Integer", help = 'Number of threads to use')
@click.option('-s', '--snakemake', type = str, metavar = "String", help = 'Additional Snakemake parameters, in quotes')
def align(genome, threads, method, ema_bins, directory, extra_params, quality_filter, snakemake):
    """
    Align sample sequences to a reference genome

    ## methods
    - **bwa**: uses BWA MEM to align reads, retaining BX tags in the alignments
    - **ema**: uses the BX barcode-aware EMA aligner. Note that EMA marks split
    reads as secondary reads, which makes it less useful with leviathan and 
    problematic with naibr variant callers.
    """
    # extension guessing
    fqext, Rsep = fq_extension(directory)
    try:
        fullext = [f".{Rsep[0]}.{fqext}", f".{Rsep[1]}.{fqext}"]
        samplenames = getnames_err(directory, fullext[0])
    except:
        try:
            fullext = [f"_{fqext[1][0]}.{fqext[0]}", f"_{fqext[1][1]}.{fqext[0]}"]
            samplenames = getnames_err(directory, fullext[0])
        except:
            print(f"\033[1;33mERROR:\033[00m No fastq files with acceptable names found in {directory}")
            print("Check that the files conform to [.1. | .F. | .R1.][.fastq | .fq].gz")
            print("Read the documentation for details: https://pdimens.github.io/harpy/modules/readmapping/")
            sys.exit(1)
    mapper = method
    command = f'snakemake --cores {threads} --directory . --snakefile {harpypath}/align-{mapper}.smk'.split()
    if snakemake is not None:
        [command.append(i) for i in snakemake.split()]
    command.append('--config')
    directory = directory.rstrip("/^")
    command.append(f"seq_directory={directory}")
    command.append(f"fqext={fqext}")
    command.append(f"Rsep={Rsep}")
    command.append(f"samplenames={samplenames}")
    command.append(f"genomefile={genome}")
    command.append(f"EMA_bins={ema_bins}")
    command.append(f"quality={quality_filter}")

    if extra_params is not None:
        command.append(f"extra={extra_params}")
    subprocess.run(command)



@click.command(no_args_is_help = True)
@click.option('-g', '--genome', type=click.Path(exists=True), required = True, metavar = "File Path", help = 'Genome assembly for variant calling')
@click.option('-d', '--directory', required = True, type=click.Path(exists=True), metavar = "Folder Path", help = 'Directory with BAM alignments')
@click.option('-p', '--populations', type=click.Path(exists = True), metavar = "File Path", help = 'Optional tab-delimited file of sample<tab>population')
@click.option('-x', '--ploidy', default = 2, show_default = True, type=click.IntRange(1,12), metavar = "Integer", help = 'Ploidy of samples')
@click.option('-m', '--method', default = "mpileup", show_default = True, type = click.Choice(["mpileup", "leviathan", "naibr"], case_sensitive = False), metavar = "String", help = "Method for calling variants")
#@click.option('-l', '--leviathan', is_flag=True, metavar = "Toggle", help="Call variants with Leviathan instead of bcftools")
#@click.option('-n', '--naibr', is_flag=True, metavar = "Toggle", help="Call variants with naibr instead of bcftools")
@click.option('-x', '--extra-params', type = str, metavar = "String", help = 'Additional mpileup/leviathan parameters, in quotes')
@click.option('-t', '--threads', default = 4, show_default = True, type = click.IntRange(min = 4, max_open = True), metavar = "Integer", help = 'Number of threads to use')
@click.option('-s', '--snakemake', type = str, metavar = "String", help = 'Additional Snakemake parameters, in quotes')
def variants(genome, threads, directory, populations, ploidy, method, extra_params, snakemake):
    """
    Call variants from sample alignments
    
    Optionally, use **harpy extra --popgroup** to create a sample grouping file to use with `--populations`.
    
    ## methods

    - **mpileup**: calls SNPS and indels
    - **leviathan**: calls inversions, duplicates, deletions, breakends
    - **naibr**: calls inversions, duplicates, deletions

    """
    samplenames = getnames_err(directory, '.bam')
    vcaller = method
    if vcaller in ["leviathan", "naibr"] and populations is not None:
        vcaller += "-pop"
    command = (f'snakemake --cores {threads} --directory . --snakefile {harpypath}/variants-{vcaller}.smk').split()
    if snakemake is not None:
        [command.append(i) for i in snakemake.split()]
    command.append('--config')
    directory = directory.rstrip("/^")
    command.append(f"seq_directory={directory}")
    command.append(f"samplenames={samplenames}")
    if populations is not None:
        command.append(f"groupings={populations}")
    command.append(f"ploidy={ploidy}")
    command.append(f"genomefile={genome}")
    if extra_params is not None:
        command.append(f"extra={extra_params}")
    subprocess.run(command)

#@click.option('-f', '--filter', is_flag=True, help="Filter VCF file to keep SNPs with QUAL>20 and DP>10")
@click.command(no_args_is_help = True)
@click.option('-v', '--vcf', required = True, type=click.Path(exists=True),metavar = "File Path", help = 'Path to BCF/VCF file')
@click.option('-d', '--directory', required = True, type=click.Path(exists=True), metavar = "Folder Path", help = 'Directory with sequence alignments (*.bam)')
@click.option('-p', '--parameters', required = True, type=click.Path(exists=True), metavar = "File Path", help = 'STITCH parameter file (tab-delimited)')
#@click.option('-x', '--extra-params', default = "", type = str, metavar = "String", help = 'Additional STITCH parameters, in quotes')
@click.option('-t', '--threads', default = 4, show_default = True, type = click.IntRange(min = 4, max_open = True), metavar = "Integer", help = 'Number of threads to use')
@click.option('-s', '--snakemake', type = str, metavar = "String", help = 'Additional Snakemake parameters, in quotes')
def impute(parameters, directory, threads, vcf, snakemake):
    """
    Impute genotypes using variants and sequences
    
    Requires a parameter file, use **harpy extra --stitch-params** to generate one and adjust it for your study.
    """
    vcfcheck(vcf)
    samplenames = getnames(directory, '.bam')
    command = f'snakemake --cores {threads} --directory . --snakefile {harpypath}/impute.smk'.split()
    if snakemake is not None:
        [command.append(i) for i in snakemake.split()]
    command.append('--config')
    directory = directory.rstrip("/^")
    command.append(f"seq_directory={directory}")
    command.append(f"samplenames={samplenames}")
    command.append(f"variantfile={vcf}")
    command.append(f"paramfile={parameters}")
    command.append(f"filtervcf=False")
    #command.append(f"extra={extra_params}")
    subprocess.run(command)

@click.command(no_args_is_help = True)
@click.option('-v', '--vcf', required = True, type=click.Path(exists=True), metavar = "File Path", help = 'Path to BCF/VCF file')
@click.option('-d', '--directory', required = True, type=click.Path(exists=True), metavar = "Folder Path", help = 'Directory with sequence alignments (*.bam)')
@click.option('-m', '--molecule-distance', default = 20000, show_default = True, type = int, metavar = "Integer", help = 'Base-pair distance delineating separate molecules')
@click.option('-p', '--prune-threshold', default = 7, show_default = True, type = click.IntRange(0,100), metavar = "Integer", help = 'PHRED-scale threshold (%) for pruning low-confidence SNPs (larger prunes more.)')
@click.option('-x', '--extra-params', type = str, metavar = "String", help = 'Additional HapCut2 parameters, in quotes')
@click.option('-t', '--threads', default = 4, show_default = True, type = click.IntRange(min = 2, max_open = True), metavar = "Integer", help = 'Number of threads to use')
@click.option('-s', '--snakemake',  type = str, metavar = "String", help = 'Additional Snakemake parameters, in quotes')
def phase(vcf, directory, threads, molecule_distance, prune_threshold, snakemake, extra_params):
    """
    Phase SNPs into haplotypes
    """
    vcfcheck(vcf)
    if vcf.lower().endswith(".vcf.gz"):
        print(f"Notice: HapCut2 does not accept gzipped vcf files. Converting to bcf.")
        variantfile = vcf[0:-7] + ".bcf"
        subprocess.run(f"bcftools view {vcf} -Ob > {variantfile}".split())
    else:
        variantfile = vcf
    samplenames = getnames(directory, '.bam')
    prune_threshold /= 100
    command = f'snakemake --cores {threads} --directory . --snakefile {harpypath}/phase.smk'.split()
    if snakemake is not None:
        [command.append(i) for i in snakemake.split()]
    command.append('--config')
    directory = directory.rstrip("/^")
    command.append(f"seq_directory={directory}")
    command.append(f"samplenames={samplenames}")
    command.append(f"variantfile={variantfile}")
    command.append(f"prune={prune_threshold}")
    command.append(f"molecule_distance={molecule_distance}")
    if extra_params is not None:
        command.append(f"extra={extra_params}")
    subprocess.run(command)

cli.add_command(extra)
cli.add_command(trim)
cli.add_command(align)
cli.add_command(variants)
cli.add_command(impute)
cli.add_command(phase)

if __name__ == '__main__':
    cli()