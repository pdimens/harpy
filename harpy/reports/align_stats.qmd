---
title: "Alignment Summary - `r params$sample`"
params:
  bxstats: 'sample.bxstats.gz'
  coverage: 'sample.cov.gz'
  molcov: 'sample.molcov.gz'
  mol_dist: 75000
  windowsize: 50000
  contigs: "default"
  sample: "sample"
---
`r format(Sys.time(), 'üóìÔ∏è %d %B, %Y üïî %H:%M')`

# Barcode Stats
```{r package_imports, results = F}
using<-function(...) {
    libs<-unlist(list(...))
    req<-unlist(lapply(libs,require,character.only=TRUE))
    need<-libs[req==FALSE]
    if(length(need)>0){ 
        install.packages(need, repos = "https://cloud.r-project.org/")
        lapply(need,require,character.only=TRUE)
    }
}
using("dplyr","highcharter","DT","BioCircos")
```

```{r import_file, results = F}
#infile <- "~/test.gz"
#samplename <- "test sample"
#sm_moldist <- 50000
infile <- params$bxstats
samplename <- params$sample
sm_moldist <- params$mol_dist
bamfile <- paste0(samplename, ".bam")
tb <- read.table(infile, header = T, sep = "\t") %>% select(-start, -end)
if(nrow(tb) == 0){
  print(paste("Input data file",infile, "is empty"))
  knitr::knit_exit()
}
tb$valid <- tb$molecule != "invalidBX"
```

```{r valids, results=F}
valids <- tb[tb$valid, -ncol(tb)]
if(nrow(valids) == 0){
  VALID_PRESENT <- FALSE
  SKIPTEXT <- TRUE
} else {
  VALID_PRESENT <- TRUE
  SKIPTEXT <- FALSE
}
```

```{r bxper, results = F}
invalids <- tb[!(tb$valid), -ncol(tb)]
valids$molecule <- as.integer(valids$molecule)
nBX <- group_by(valids, contig) %>% 
  summarize(nBX = length(molecule))

avgBX <- round(mean(nBX$nBX), digits = 2)
totuniqBX <- read.table(infile, header = F, sep = "\n", as.is = T, skip = nrow(tb) + 1, comment.char = "+")
totuniqBX <- gsub("#total unique barcodes: ", "", totuniqBX) |> as.integer()

tot_valid <- sum(valids$reads)
tot_invalid <- sum(invalids$reads)

non_singletons <- valids[valids$reads >= 2, ]
n_non_singleton_mol <- nrow(non_singletons)
```

```{r nxx, results = F}
NX <- function(lengths, X=50){
  lengths <- as.numeric(sort(lengths, decreasing=TRUE))
  index <- which(cumsum(lengths) / sum(lengths) >= X/100)[1]
  return(lengths[index])
}
```

##
```{r}
#| content: valuebox
#| title: "Contigs"
list(
  color = "light",
  value = scales::comma(length(unique(tb$contig)))
)
```

```{r}
#| content: valuebox
#| title: "Unique Barcodes"
list(
  color = "#d4d4d4",
  value = scales::comma(totuniqBX)
)
```

```{r}
#| content: valuebox
#| title: "Molecule Threshold"
if(sm_moldist > 0){
  boxval <- scales::comma(sm_moldist)
} else {
  boxval <- "NA"
}
list(
  color = "#d4d4d4",
  value = boxval
)
```

```{r}
#| content: valuebox
#| title: "Unique Molecules"
list(
  color = "#d4d4d4",
  value = scales::comma(length(unique(valids$molecule)))
)
```

```{r}
#| content: valuebox
#| title: "Valid BX Records"
list(
  color = "#d4d4d4",
  value = scales::comma(tot_valid)
)
```

```{r}
#| content: valuebox
#| title: "Invalid BX Records"
list(
  color = "#d4d4d4",
  value = scales::comma(tot_invalid)
)
```

```{r}
#| content: valuebox
#| title: "Singletons (%)"
if (VALID_PRESENT){
  boxval <- round(sum(valids$reads < 2)/nrow(valids) * 100, 2)
} else {
  boxval <- "NA"
}
list(
  color = "#d4d4d4",
  value = boxval
)
```

```{r}
#| content: valuebox
#| title: "Avg molecules per contig"
if (VALID_PRESENT){
  boxval <- scales::comma(avgBX)
} else {
  boxval <- "NA"
}
list(
  color = "#d4d4d4",
  value = boxval
)
```

##
::: {.card fill="false"}

```{r NX_stats, eval = VALID_PRESENT}
#| title: "Stats by Contig"
if(!VALID_PRESENT){
  cat(paste0("**`",infile,"` has no valid haplotagging barcodes, skipping reporting on linked-read metrics.**"))
} else {
  summary_table <- valids %>% 
      group_by(contig) %>%
      summarize(valid_records = sum(reads), molecules = length(molecule),n50 = NX(length_inferred, 50), n75 = NX(length_inferred, 75), n90 = NX(length_inferred, 90))
  summ_invalid <- invalids %>% group_by(contig) %>% summarize(invalid_records = sum(reads))
  summary_table <- left_join(summary_table, summ_invalid, by = "contig", keep = T) %>% select(1, 2, 8, 3:6)
  summary_table$invalid_records[is.na(summary_table$invalid_records)] <- 0
  DT::datatable(
    summary_table,
    rownames = F,
    colnames = c("contig", "valid BX records", "invalid BX records", "molecules", "N50", "N75", "N90"),
    fillContainer = T,
    options = list(
      dom = 'Brtp',
      paging = TRUE,
      buttons = list(list(extend = "csv",filename = paste0(samplename ,"_molecule_NX")))
    )
  )
}
```
:::

## Reads per molecule 
::: {.card title="Reads per Molecule"}

This chart shows the distribution of the number of reads per haplotag molecule. That is, how many alignments
are associated with a unique molecule. This excludes the number of reads associated with invalid
or absent haplotag barcodes. There are two distributions: one with `all` the alignments (purple)
and another with only `non-singletons` (green). The percent of molecules in the `non-singletons`
distribution is relative to the total number of non-singleton molecules.

```{r readsper, out.width = '100%', eval = VALID_PRESENT}
hs <- hist(valids$reads, breaks = min(valids$reads):max(valids$reads), plot = F)
hs_mult <- hist(non_singletons$reads, breaks = hs$breaks, plot = F)
hs$counts <- round(hs$counts / sum(hs$counts) * 100, 4)
hs_mult$counts <- round(hs_mult$counts / sum(hs_mult$counts) * 100, 4)
hs <- data.frame(val = hs$breaks[-1], freq = hs$counts)
hs_mult <- data.frame(val = hs_mult$breaks[-1], freq = hs_mult$counts)

highchart() |>
  hc_chart(type = "area", animation = F) |>
  hc_add_series(data = hs, type = "areaspline", hcaes(x = val, y = freq), color = "#eeaf61", name = "all", marker = list(enabled = FALSE)) |>
  hc_add_series(data = hs_mult, type = "areaspline", hcaes(x = val, y = freq), color = "#84bd9e", name = "non-singletons", marker = list(enabled = FALSE)) |>
  hc_title(text = "Reads Per Molecule") |>
  hc_xAxis(title = list(text = "reads per molecule")) |>
  hc_yAxis(max = 100, title = list(text = "% molecules")) |>
  hc_caption(
    text = paste0("unique molecules: ", totuniqBX, " (", n_non_singleton_mol, " non-singletons)")
  ) |>
  hc_tooltip(crosshairs = TRUE) |>
  hc_exporting(enabled = T, filename = paste0(samplename, ".readsper"),
    buttons = list(contextButton = list(menuItems = c("downloadPNG", "downloadJPEG", "downloadPDF", "downloadSVG")))
  )
```
:::

### bases per desc
::: {.card title="Total Bases Aligned"}

This is a frequency distribution showing the number of base pairs aligned
per unique molecule. These data are shown in 500 bp bins. Be aware that the Y axis
may not start at `0`. There are two distributions: one with `all` the alignments (purple)
and another with only `non-singletons` (green). The percent of molecules in the `non-singletons`
distribution is relative to the total number of non-singleton molecules.

```{r basesper, out.width="100%", eval = VALID_PRESENT}
hs <- hist(round(valids$aligned_bp, -2), breaks = 50,  plot = F)
hs_mult <- hist(round(non_singletons$aligned_bp, -2), breaks = hs$breaks,  plot = F)
hs$counts <- round(hs$counts / sum(hs$counts)*100,4)
hs_mult$counts <- round(hs_mult$counts / sum(hs_mult$counts)*100,4)
hs <- data.frame(val = hs$breaks[-1], freq = hs$counts)
hs_mult <- data.frame(val = hs_mult$breaks[-1], freq = hs_mult$counts)

highchart() |>
  hc_chart(type = "area", animation = F) |>
  hc_add_series(data = hs, type = "areaspline", hcaes(x = val, y = freq), color = "#eeaf61", name = "all", marker = list(enabled = FALSE)) |>
  hc_add_series(data = hs_mult, type = "areaspline", hcaes(x = val, y = freq), color = "#84bd9e", name = "non-singletons", marker = list(enabled = FALSE)) |>
  hc_title(text = "Bases Aligned Per Molecule") |>
  hc_xAxis(title = list(text = "aligned bases per molecule")) |>
  hc_yAxis(max = 100, title = list(text = "% molecules")) |>
  hc_caption(
    text = paste0("unique molecules: ", totuniqBX, " (", n_non_singleton_mol, " non-singletons)")
  ) |>
  hc_tooltip(crosshairs = TRUE) |>
  hc_exporting(enabled = T, filename = paste0(samplename, ".basesper"),
    buttons = list(contextButton = list(menuItems = c("downloadPNG", "downloadJPEG", "downloadPDF", "downloadSVG")))
  )
```
:::

##
:::{.card title="Inferred Molecule Lengths"}
This is the frequency distribution of molecule lengths 
inferred from the first and last alignment positions along a contig for all
alignments associated with a single haplotag barcode on a given contig. 
Be aware that the Y axis may not start at `0`. There are two distributions:
one with `all` the alignments (purple) and another with only `non-singletons`
(green). The percent of molecules in the `non-singletons` distribution is
relative to the total number of non-singleton molecules.

```{r inferred, out.width = '100%', eval = VALID_PRESENT}
hs <- hist(round(valids$length_inferred / 1000,0),breaks = 25,plot = F)
hs_mult <- hist(round(non_singletons$length_inferred / 1000,0),breaks = hs$breaks,plot = F)
hs$counts <- round(hs$counts / sum(hs$counts)*100,2)
hs_mult$counts <- round(hs_mult$counts / sum(hs_mult$counts)*100,2)
hs <- data.frame(val = hs$breaks[-1], freq = hs$counts)
hs_mult <- data.frame(val = hs_mult$breaks[-1], freq = hs_mult$counts)

highchart() |>
  hc_chart(type = "area", animation = F) |>
  hc_add_series(data = hs, type = "areaspline", hcaes(x = val, y = freq), color = "#eeaf61", name = "all", marker = list(enabled = FALSE)) |>
  hc_add_series(data = hs_mult, type = "areaspline", hcaes(x = val, y = freq), color = "#84bd9e", name = "non-singletons", marker = list(enabled = FALSE)) |>
  hc_title(text = "Inferred Molecule Length") |>
  hc_subtitle(text = "lengths reported as kilobases (kbp)") |>
  hc_xAxis(max = 100, title = list(text = "Inferred Molecule length (kbp)"), type = "logarithmic") |>
  hc_yAxis(title = list(text = "% of molecules")) |>
  hc_caption(
    text = paste0("unique molecules: ", totuniqBX, " (", n_non_singleton_mol, " non-singletons)")
  ) |>
  hc_tooltip(crosshairs = TRUE) |>
  hc_exporting(enabled = T, filename = paste0(samplename, ".mollen"),
    buttons = list(contextButton = list(menuItems = c("downloadPNG", "downloadJPEG", "downloadPDF", "downloadSVG")))
  )
```
:::

##
:::{.card title="Read Coverage"}

This chart shows molecule coverage as computed by the number of bases aligned
to that molecule. In other words, "_how much of each unique long molecule is actually sequenced/aligned?_"
Keep in mind there is a distinction between sequences and alignments, since
some sequences belonging to a particular molecule may not align well and wouldn't
appear in the alignment data.  

```{r inferred_cov_bp, out.width = '100%', eval = VALID_PRESENT}
hs <- hist(round(valids$coverage_bp, 0), breaks = seq(0, 1, by = 0.05), plot = F)
hs_mult <- hist(round(non_singletons$coverage_bp, 0), breaks = hs$breaks, plot = F)
hs$counts <- round(hs$counts / sum(hs$counts)*100, 4)
hs_mult$counts <- round(hs_mult$counts / sum(hs_mult$counts)*100, 4)
hs <- data.frame(val = hs$breaks[-1], freq = hs$counts)
hs_mult <- data.frame(val = hs_mult$breaks[-1], freq = hs_mult$counts)

highchart() |>
  hc_chart(type = "area", animation = F) |>
  hc_add_series(data = hs, type = "areaspline", hcaes(x = val, y = freq), color = "#eeaf61", name = "all", marker = list(enabled = FALSE)) |>
  hc_add_series(data = hs_mult, type = "areaspline", hcaes(x = val, y = freq), color = "#84bd9e", name = "non-singletons", marker = list(enabled = FALSE)) |>
  hc_title(text = "Percent Molecule Coverage by Aligned Bases") |>
  hc_xAxis(title = list(text = "% molecule covered")) |>
  hc_yAxis(max = 100, title = list(text = "% of molecules")) |>
  hc_caption(
    text = paste0("unique molecules: ", totuniqBX, " (", n_non_singleton_mol, " non-singletons)")
  ) |>
  hc_tooltip(crosshairs = TRUE) |>
  hc_exporting(enabled = T, filename = paste0(samplename, ".molcov"),
    buttons = list(contextButton = list(menuItems = c("downloadPNG", "downloadJPEG", "downloadPDF", "downloadSVG")))
  )
```
:::

::: {.card title="Molecular Coverage"}
This chart shows *molecule coverage* as computed by the _inferred fragment_ from which the aligned sequences originate.
Unlike read coverage, this calculation takes into account the total insert size, including unsequenced gaps between
the forward and reverse reads.

```{r inferred_cov_insert, out.width = '100%', eval = VALID_PRESENT}
hs <- hist(round(valids$coverage_inserts, 0), breaks = seq(0, 1, by = 0.05), plot = F)
hs_mult <- hist(round(non_singletons$coverage_inserts, 0), breaks = hs$breaks, plot = F)
hs$counts <- round(hs$counts / sum(hs$counts)*100,2)
hs_mult$counts <- round(hs_mult$counts / sum(hs_mult$counts)*100,2)
hs <- data.frame(val = hs$breaks[-1], freq = hs$counts)
hs_mult <- data.frame(val = hs_mult$breaks[-1], freq = hs_mult$counts)

highchart() |>
  hc_chart(type = "area", animation = F) |>
  hc_add_series(data = hs, type = "areaspline", hcaes(x = val, y = freq), color = "#eeaf61", name = "all", marker = list(enabled = FALSE)) |>
  hc_add_series(data = hs_mult, type = "areaspline", hcaes(x = val, y = freq), color = "#84bd9e", name = "non-singletons", marker = list(enabled = FALSE)) |>
  hc_title(text = "Percent Molecule Coverage by Inferred Insert Size") |>
  hc_xAxis(title = list(text = "% molecule covered")) |>
  hc_yAxis(max = 100, title = list(text = "% of molecules")) |>
  hc_caption(
    text = paste0("unique molecules: ", totuniqBX, " (", n_non_singleton_mol, " non-singletons)")
  ) |>
  hc_tooltip(crosshairs = TRUE) |>
  hc_exporting(enabled = T, filename = paste0(samplename, ".molcov"),
    buttons = list(contextButton = list(menuItems = c("downloadPNG", "downloadJPEG", "downloadPDF", "downloadSVG")))
  )
```
:::

# Depth Stats
```{r reset_env}
# clear out objects in memory to reduce RAM usage
rm(hs)
rm(hs_mult)
rm(valids)
rm(invalids)
rm(non_singletons)
#knitr::knit_exit()
```
```{r imports}
covfile <- params$coverage
molcovfile <- params$molcov
windowsize <- as.integer(params$windowsize)
samplename <- params$sample
#samplename <- "test sample"
#windowsize <- 50000
#covfile <- "~/cov.gz"
#molcovfile <- "~/molcov.gz"
tb <- read.table(covfile, header = F)
if(nrow(tb) == 0){
  print(paste("Input data file", covfile, "is empty"))
  knitr::knit_exit()
}
tbmol <- read.table(molcovfile, header = F)
if(nrow(tbmol) == 0){
  print(paste("Input data file", molcovfile, "is empty"))
  knitr::knit_exit()
}
```

```{r setup_cov_table}
colnames(tb) <- c("contig", "position", "depth")
colnames(tbmol) <- c("contig", "position", "mol_depth")
tb <- merge(tb, tbmol, by = c("contig", "position"))
q99 <- quantile(tb$depth, 0.99)
mol_q99 <- quantile(tb$mol_depth, 0.99)
names(q99) <- NULL
names(mol_q99) <- NULL
windowskb <- round(windowsize/1000, 0)
rm(tbmol)
```

```{r summary_stats}
global_avg <- mean(tb$depth)
global_sd <- sd(tb$depth)
mol_global_avg <- mean(tb$mol_depth)
mol_global_sd <- sd(tb$mol_depth)

tb$outlier <- tb$depth > q99
outliers <- tb[tb$outlier, -5]
nonoutliers <- tb[!(tb$outlier), -5]

contig_avg <- group_by(tb, contig) %>%
  summarize(average = mean(depth), mol_average = mean(mol_depth), sdv = sd(depth), mol_sdv = sd(mol_depth))
contig_avg <- rbind(data.frame(contig = "global", average = global_avg, sdv = global_sd, mol_average = mol_global_avg, mol_sdv = mol_global_sd), contig_avg) %>% 
  mutate(average = round(average, 2), sdv = round(sdv, 2), mol_average = round(mol_average, 2), mol_sdv = round(mol_sdv, 2))
```

##
```{r}
#| content: valuebox
#| title: "Contigs"
list(
  color = "#ffffff",
  value = scales::comma(length(unique(tb$contig)))
)
```

```{r}
#| content: valuebox
#| title: "Intervals"
list(
  color = "#d4d4d4",
  value = paste(windowskb, "kb")
)
```

```{r}
#| content: valuebox
#| title: "Average Depth"
list(
  color = "#d4d4d4",
  value = round(global_avg,2)
)
```

```{r}
#| content: valuebox
#| title: "Stdev Depth"
list(
  color = "#d4d4d4",
  value = round(global_sd,2)
)
```

```{r}
#| content: valuebox
#| title: "Mol. Average Depth"
list(
  color = "#d4d4d4",
  value = round(mol_global_avg,2)
)
```

```{r}
#| content: valuebox
#| title: "Mol. Stdev Depth"
list(
  color = "#d4d4d4",
  value = round(global_sd,2)
)
```

## Distdesc header
::: {.card title="Alignment Depth Distribution"}
These are the frequencies of interval coverage across all **`r windowskb` kilobase** intervals for all contigs.
For visual clarity, the distribution of alignment-depths (not molecule depths) is truncated at the 99% quantile, which is **`r q99`** for the alignment data.

```{r depth_distribution}
hs <- hist(tb$depth[tb$depth <= q99], breaks = 30, plot = F)
hs_mol <- hist(tb$mol_depth[tb$mol_depth <= mol_q99], breaks = 30, plot = F)
hs$counts <- round(hs$counts / sum(hs$counts) * 100, 2)
hs_mol$counts <- round(hs_mol$counts / sum(hs_mol$counts) * 100, 2)
hs <- data.frame(val = hs$breaks[-1], freq = hs$counts)
hs_mol <- data.frame(val = hs_mol$breaks[-1], freq = hs_mol$counts)

highchart() |>
  hc_chart(type = "area", animation = F) |>
  hc_add_series(data = hs, type = "areaspline", color = "#757575", name = "by alignments", hcaes(x = val, y = freq),  marker = list(enabled = FALSE)) |>
  hc_add_series(data = hs_mol, type = "areaspline", hcaes(x = val, y = freq), color = "#9c3b94", name = "by inferred molecules", marker = list(enabled = FALSE)) |>
  hc_xAxis(max = mol_q99, title = list(text = "depth")) |>
  hc_yAxis(title = list(text = "% intervals"))  |>
  hc_caption(text = "inferred molecules calculate \"effective\" or \"molecule\" coverage") |>
  hc_title(text = "Distribution of Alignment Depths")  |>
  hc_exporting(
    enabled = T, filename = paste0(samplename, ".cov"),
    buttons = list(contextButton = list(menuItems = c("downloadPNG", "downloadJPEG", "downloadPDF", "downloadSVG")))
  )
```

:::

## Sumheader
::: {.card title="Average Depth"}
This table shows the global and per-contig average depth and standard 
deviation per `r windowskb`kbp intervals **including** intervals whose depth is flagged
an outlier in the data. 

```{r depth_table}
DT::datatable(
  contig_avg, 
  rownames = F, 
  extensions = 'Buttons', 
  options = list(
    dom = 'Brtp',
    scrollX = TRUE,
    paging = TRUE,
    buttons = list(list(extend = "csv",filename = paste0(samplename ,"_align_depth_avg")))
  ),
  colnames = c('Contig', 'Average Depth', 'Standard Deviation', 'Average Depth (molecules)', 'Standard Deviation (Molecules)'),
  fillContainer=T
)
```
:::

###
::: {.card title="Depth Outliers"}
This table shows the `r windowskb`kbp intervals considered outliers, as determined by 
having depth greater than the 99th percentile (`r q99`) of aligment depths. 

```{r depth_plot}
DT::datatable(
  outliers, 
  rownames = F, 
  extensions = 'Buttons', 
  options = list(
    dom = 'Brtp',
    scrollX = TRUE,
    paging = TRUE,
    buttons = list(list(extend = "csv",filename = paste0(samplename ,"_align_depth_outlier_avg")))
  ),
  colnames = c('Contig', 'Interval', 'Depth', 'Depth (molecules)'),
  fillContainer=T
)
```
:::

# Depth Plot
```{r disttext}
if(params$mol_dist > 0){
  dist_text <- paste0("from the linked-read information with a distance threshold of ", params$mol_dist)
} else {
  dist_text <- "by the internal EMA aligner heuristics"
}
```
##
::: {.card title="Depth and Coverage, Visualized" fill="false"}
This is a circular vizualization the depth information across up to 30 of the largest contigs (unless specific contigs were provided).
For clarity, this visualization truncates coverage at the 99th percentile (`r q99` for alignments and `r mol_q99` for molecule coverage).
If you are unfamiliar with this kind of visualization, it's a circular representation of a linear genome. 
Each arc (segment) is a different contig, from position 0 to the end of the contig, and is labelled by the contig name.
The internal (grey) rings are a barplot where each bar represents the alignment depth at a `r windowskb` kilobase
genomic interval. The inner ring (grey bars) is the number of reads that had a _proper_ alignment in the `r windowskb` kilobase interval, where
"proper" refers to a read not marked as a duplicate or flagged with the SAM `UNMAP`, `SECONDARY`,  or `QCFAIL` flags. The outer ring (magenta bars),
is the number of _molecules_ spanning that interval, where molecules are inferred `r dist_text`.
:::

##
### {width=20%}
::: {.card title="Navigating the Plot"}
You may hover your cursor over variants to view their positions, pan by clicking and dragging,
and zoom using scroll (mouse or touchpad). In case you become unable to scroll up from the plot due to these interactive 
features, place your cursor over this left column and you will
be able to scroll the report instead of zooming on the plot.
:::

###
```{r limit_contigs}
plot_contigs <- params$contigs
#plot_contigs <- "default"
# Find the 30 largest contigs
contigs <- group_by(tb, contig) %>%
  summarize(size = max(position)) %>%
  arrange(desc(size))
  
if (all(plot_contigs == "default")){
  # limit the data to only the 30 largest contigs
  if (nrow(contigs) > 30){
    .contigs <- contigs[1:30, ]
    tb <- filter(tb, contig %in% .contigs$contig)
  } else {
    .contigs <- contigs
  }
} else {
  .contigs <- filter(contigs, contig %in% plot_contigs)
  tb <- filter(tb, contig %in% plot_contigs)
}

```

```{r circleplot, fig.align='center', out.width= "80%", out.height="900px"}
#| title: Depth and Coverage Across the Genome

genomeChr <- .contigs$size
names(genomeChr) <- .contigs$contig
genomeChr <- as.list(genomeChr)
inner <- c(0.2, 0.6)
outer <- c(0.61, 0.97)
tracks <- BioCircosTracklist()

# Add one track for each chromosome
for (i in names(genomeChr)){
  # Define histogram/bars to be displayed
  chrcov <- tb[tb$contig == i,]
  #chrcov$depth
  # Add a track with bars on the i-th chromosome
  tracks <- tracks + BioCircosBarTrack(
    paste0("cov_", i),
    chromosome = i, 
    starts = chrcov$position - windowsize, ends = chrcov$position,
    values = pmin(chrcov$depth, q99),
    color = "#757575",
    minRadius = inner[1],
    maxRadius = inner[2]
  )
  tracks <- tracks + BioCircosBarTrack(
    paste0("molcov_", i),
    chromosome = i, 
    starts = chrcov$position - windowsize, ends = chrcov$position,
    values = pmin(chrcov$mol_depth, mol_q99),
    color = "#9c3b94",
    minRadius = outer[1],
    maxRadius = outer[2]
  )
}
# Add background
tracks <- tracks + BioCircosBackgroundTrack(
  "depth_background",
  fillColors = "#f3f3f3",
  borderColors = "#C9C9C9",
  minRadius = inner[1],
  maxRadius = inner[2]
)
tracks <- tracks + BioCircosBackgroundTrack(
  "molcov_background",
  fillColors = "#f3f3f3",
  borderColors = "#C9C9C9",
  minRadius = outer[1],
  maxRadius = outer[2]
  )
BioCircos(
  tracks,
  displayGenomeBorder = F,
  genome = genomeChr,
  chrPad = 0.02,
  genomeTicksDisplay = F,
  BARMouseOverColor = "#1cff42",
  BARMouseOverTooltipsHtml05 = "Mean Depth: ",
  genomeLabelDy = 0,
  width = "100%"
)
```


# Supporting Info
##
::: {.card title="Interpreting the Supporting File"}
Below are the descriptions of the columns in **`r basename(infile)`**, which was created
by Harpy using the included `bx_stats.py` script. The term `molecule` refers to the
`MI:i` tag in the alignments, which is a unique molecule ID given to the original
fragment alignments sharing a barcode are inferred to have originated from. The inference
takes into account an [alignment distance threshold](https://pdimens.github.io/harpy/haplotagdata/#barcode-thresholds)
and that the sequences aligned to the same contig.

contig
: name of the contig the molecule occurs on

molecule
: the molecule name as given by the MI:i: tag

reads
: number of alignments associated with this molecule

start
: the start position of the first alignment for that molecule

end
: the end position of the last alignment for that molecule

length_inferred
: inferred length of the molecule based on the start/end of the alignments sharing the same barcode

percent_coverage
: what percent of the molecule is represented by sequence alignments

aligned_bp
: total number of base pairs aligned for that molecule
:::

###
::: {.card title="Interpreting Barcode Validity"}
BX barcode validity is classified into one of two categories:

valid BX
: a complete BX barcode was present in the read (i.e. no 00 for any segments)

invalid BX
: a barcode was present in the read, but it contained 00 in at least one of the barcode segments
:::