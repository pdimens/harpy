---
title: "Haplotag Molecule Report"
date: "`r format(Sys.time(), '%m-%d-%y %X')`"
output:
  flexdashboard::flex_dashboard:
    theme: lumen
    orientation: rows
    vertical_layout: scroll
    horizontal_layout: fill
    favicon: "https://raw.githubusercontent.com/pdimens/harpy/docs/static/favicon_dark.png"
---

```{r echo = F, results = F, message = F}
library(flexdashboard)
library(dplyr)
library(ggplot2)
library(plotly)
library(magrittr)
library(DT)
library(scales)
```

```{r echo = F, results = F, message = F}
#infile <- "~/file.bxstats.gz"
#mdist <- scales::comma(200000)
infile <- snakemake@input[[1]]
mdist <- snakemake@params[[1]]
bamfile <- gsub(".bxstats.gz", ".bam", infile)
samplename <- gsub(".bxstats.gz", "", basename(infile))
tb <- read.table(infile, header = T, sep = "\t") %>% select(-start, -end)
tb$valid <- tb$molecule
tb[!(tb$valid %in% c("noBX", "invalidBX")), "valid"] <- "valid BX"
tb$valid <- gsub("BX", " BX", tb$valid)
```

```{r bxper, echo = F, results = F, message = F}
valids <- filter(tb, valid == "valid BX")
nBX <- group_by(valids, contig) %>% 
  summarize(nBX = length(molecule))

avgBX <- round(mean(nBX$nBX), digits = 2)

totuniqBX <- length(unique(valids$molecule))

tots <- tb %>% 
    group_by(valid) %>%
    summarize(total = length(molecule)) %>% 
    as.data.frame()
for(i in c("no BX", "invalid BX", "valid BX")){
  if (!(i %in% tots$valid)){
    tots <- rbind(tots, data.frame("valid" = i, total = 0))
  }
}
```

```{r binformatter, echo = F, results = F, message = F}
formatBins <- function(x){
    spl <- strsplit(levels(x), ",")
    lefts <- gsub("\\(", "", sapply(spl, "[[", 1)) |> as.numeric() |> scales::comma()
    rights <- gsub("\\]", "", sapply(spl, "[[", 2)) |> as.numeric()
    rights <- scales::comma(rights - 1)
    return(
        paste(lefts, rights, sep = "-")
    )
}
```

```{r nxx, echo = F, results = F, message = F}
NX <- function(lengths, X=50){
  lengths <- as.numeric(sort(lengths, decreasing=TRUE))
  index <- which(cumsum(lengths) / sum(lengths) >= X/100)[1]
  return(lengths[index])
}
```

## fileheader
### hdr {.no-title}
<h1> Haplotag Barcode Statistics </h1>
The information presented below were gathered from the alignments within `r basename(bamfile)`.


## General Information {data-height=100}
### ncontigs
```{r}
valueBox(scales::comma(length(unique(tb$contig))), caption = "Contigs")
```

### validBX
```{r}
valueBox(scales::comma(tots[tots$valid == "valid BX", 2]), caption = "Valid Barcodes", color = "success", icon = "fa-vial-circle-check")
```

### invalidBX
```{r}
valueBox(scales::comma(tots[tots$valid == "invalid BX", 2]), caption = "Invalid Barcodes", color = "warning", icon = "fa-x")
```

### noBX
```{r}
valueBox(scales::comma(tots[tots$valid == "no BX", 2]), caption = "Missing Barcodes", color = "danger", icon = "fa-exclamation")
```

### glob-avg
```{r}
valueBox(scales::comma(avgBX), caption = "Average molecules per contig", color = "info")
```

### glob-total
```{r}
valueBox(scales::comma(totuniqBX), caption = "Total unique molecules", color = "info")
```

## N50 and N90
### Molecule Length Metrics
```{r echo = FALSE, message = FALSE, warning = FALSE, out.width = '70%'}
valids %>% 
    group_by(contig) %>%
    summarize(n50 = NX(length_inferred, 50), n75 = NX(length_inferred, 75), n90 = NX(length_inferred, 90)) %>% 
    as.data.frame() %>% knitr::kable()
```

## Reads per molecule dec
### Reads per mol dec {.no-title}
<h2> Reads per Molecule </h2>
The chart below shows the distribution of the number of reads per haplotag molecule. That is, how many alignments
are associated with a unique molecule. This excludes the number of reads associated with invalid
or absent haplotag barcodes.

### bases per desc {.no-title}
<h2> Total Bases Aligned </h2>
Below is a cumulative frequency distribution showing the number of base pairs aligned
per unique molecule. These data are shown in 500 bp bins. Pay attention to the Y axis,
as it likely doesn't start at `0`.


## Reads per molecule
### Reads per mol {.no-title}
```{r echo = FALSE, message = FALSE, warning = FALSE, out.width = '100%'}
p <- ggplot(valids, aes(reads)) +
    stat_ecdf(aes(group=1), geom="line", pad = F, color = "#8484bd") +
    stat_ecdf(aes(group=1), geom="point", pad = F, shape = 21, size = 3, fill = "#8484bd", color = "white") +
    labs(
        title = "Reads Per Unique Molecule",
        subtitle = samplename,
        caption = paste0("Total unique molecules: ", totuniqBX),
        x = "Number of aligned reads",
        y = "% of molecules",
    ) +
    theme_light() +
    scale_y_continuous(labels = label_percent()) +
    theme(panel.grid.minor.y = element_blank())

ggplotly(p)
```

### Bases Per molecule {.no-title}
```{r echo = FALSE, message = FALSE, warning = FALSE, out.width = '100%'}
dat.binned <- valids %>%
    count(Marks = cut(aligned_bp, seq(0,max(aligned_bp)+500, 500))) %>%
    mutate(pct = n/sum(n)) %>% mutate("Cumulative_Percent" = round(cumsum(pct) * 100,2), "Size_Range" = Marks)

levels(dat.binned$Size_Range) <- formatBins(dat.binned$Size_Range)

p <- ggplot(data = dat.binned, mapping = aes(Size_Range, Cumulative_Percent)) +  
  geom_line(aes(group = 1), color = "#99cccc") + 
  geom_point(size = 3, shape = 21, color = "white", fill = "#99cccc") +
  labs(
    title = "Bases Aligned Per Unique Molecule",
    subtitle = samplename,
    caption = paste0("Total unique molecules: ", totuniqBX),
    x = "Number of aligned bases (bp)",
    y = "% of molecules",
  ) +
  theme_light() +
  theme(panel.grid.minor.y = element_blank())  
ggplotly(p) %>% layout(hovermode = "x")
```
## inferred-header
### inferred desc {.no-title}
<h2> Inferred Molecule Lengths </h2>
The chart below shows the **cumulative** frequency distribution of molecule lengths 
inferred from the first and last alignment positions along a contig for all
alignments associated with a single haplotag barcode on a given contig. 
Pay attention to the Y axis, as it likely doesn't start at `0`.

### inferred_cov desc {.no-title}
<h2> Inferred Molecule Read Coverage </h2>
The chart below shows the frequency distribution of molecule coverage, meaning
the percent of each inferred molecule that has sequences aligned to it. In other
words, "how much of each unique long molecule is actually sequenced/aligned?"
Keep in mind there is a disctinction between sequences and alignments, since
some sequences belonging to a particular molecule may not align well and wouldn't
appear in the alignment data. 

## Inferred
### Inferred molecule Lengths
```{r echo = FALSE, message = FALSE, warning = FALSE, out.width = '100%'}
dat.binned <- valids %>% mutate(length_inferred = length_inferred/1000) %>%
    count(Marks = cut(length_inferred, seq(0,max(length_inferred)+5, 5))) %>%
    mutate(pct = n/sum(n)) %>% mutate("Cumulative_Percent" = round(cumsum(pct) * 100,2), "Size_Range" = Marks)

levels(dat.binned$Size_Range) <- formatBins(dat.binned$Size_Range)
p <- ggplot(data = dat.binned, mapping = aes(Size_Range, Cumulative_Percent)) +  
  geom_line(aes(group = 1), color = "#9393d2") + 
  geom_point(data = dat.binned, size = 3, shape = 21, color = "white", fill = "#6b6b9c") +
  labs(
    title = "Inferred Molecule Length",
    subtitle = samplename,
    caption = paste0("Total unique molecules: ", totuniqBX),
    x = "Molecule Size Bin (kbp)",
    y = "% of Molecules"
  ) +
  scale_y_continuous(trans = "log10") +
  theme_light() +
  theme(panel.grid.minor.y = element_blank())  

ggplotly(p) %>% layout(hovermode = "x")
```

### Inferred Molecule Coverage
```{r echo = FALSE, message = FALSE, warning = FALSE, out.width = '100%'}
dat.binned <- valids %>%
    count(Marks = cut(percent_coverage*100, seq(0,max(percent_coverage*100)+5, 5))) %>%
    mutate(pct = n/sum(n)) %>% rename("Percent_Coverage" = Marks, "Percent_Total_Molecules" = pct)
  
levels(dat.binned$Percent_Coverage) <- formatBins(dat.binned$Percent_Coverage)

p <- dat.binned %>%
  ggplot(aes(x = Percent_Coverage, y = Percent_Total_Molecules)) + 
  geom_bar(stat = "identity", fill = "#e59765", color = "white") +
  labs(
    title = "Percent Molecule Coverage",
    subtitle = samplename,
    caption = paste0("Total unique molecules: ", totuniqBX),
    x="% of Molecule Covered by Alignments",
    y="% Unique Molecules"
  ) +
  scale_y_continuous(labels = scales::percent) +
  theme_light()

ggplotly(p) %>% layout(hovermode = "x")
```

## Interpreting the supporting data
### interp desc {.no-title}
<h2> Interpreting the Data </h2>
Below are details on how to interpret the information presented in this report, as well as the 
underlying data used to create this report.

## inttable
### interpreting {.no-title}
<h3> Interpreting the Supporting File </h3>
Listed below are the descriptions of the columns in **`r basename(infile)`**, which was created
by Harpy using the included `bxStats.py` script. The term `molecule` refers to the
`MI:i` tag in the alignments, which is a unique molecule ID given to the original
fragment alignments sharing a barcode are inferred to have originated from. The inference
takes into account an [alignment distance threshold](https://pdimens.github.io/harpy/haplotagdata/#barcode-thresholds)
and that the sequences aligned to the same contig.

```{r cols_explained, echo=FALSE, message=FALSE, warnings=FALSE}
knitr::kable(
  data.frame(
    "Column Name" = c("contig", "molecule", "reads", "start", "end", "length_inferred", "percent_coverage", "aligned_bp", "mindist"),
    "Description" = c(
      "name of the contig the molecule occurs on",
      "the molecule name as given by the MI:i: tag",
      "number of alignments associated with this molecule",
      "the start position of the first alignment for that molecule",
      "the end position of the last alignment for that molecule",
      "inferred length of the molecule based on the start/end of the alignments sharing the same barcode",
      "what percent of the molecule is represented by sequence alignments",
      "total number of base pairs aligned for that molecule",
      "the minimum basepair distance between two alignments sharing a barcode (excluding read pairs, kind of a sanity check)"
      )
    )
)
```

## Interpreting this report
### Barcode validity {.no-title}
<h3> Interpreting Barcode Validity </h3>
BX barcode validity is classified into one of three categories:

```{r bx_explanation, echo=FALSE, message=FALSE, warnings=FALSE}
knitr::kable(
  data.frame(
    "Classification" = c("valid BX", "invalid BX", "no BX"),
    "Description" = c(
      "a complete BX barcode was present in the read (i.e. no 00 for any segments)",
      "a barcode was present in the read, but it contained 00 in at least one of the barcode segments",
      "no barcode was present in the read"
      )
    )
)
```

### Molecule splitting {.no-title}
<h3> Molecule Splitting, Explained </h3>

It's common for a barcode shared by reads not originating from the same molecule
to reappear much further along a chromosome or across multiple chromosomes. The 
process that derives the data in this report separates those recurring barcodes
as unique molecules when their distance is greater than a predetermined threshold. 
If aligned with `BWA` or `minimap2`, Harpy added a corresponding `MI:i:` (Molecular
Identifier) tag that reflects splits given the molecule distance threshold you
specified (`r mdist`). If aligned with `EMA`, the `EMA` software itself 
determines the splits and assigns the `MI:i` tag without user specification.
